

 static public class MBCR_pid
    {
        static public int label = 0;//表明这个class被调用了       
        //PID：
        static public double err_sum = 0;
        static public double err_last = 0;
        static public double kp = 0.22;
        static public double ki = 0.13;
        static public double kd = 0;

        static public ArrayList err_ArrayList = new ArrayList();        
       static public ArrayList err_ArrayList_new = new ArrayList();
        static public ArrayList errTime_ArrayList = new ArrayList();
        static public ArrayList err_ArrayList_all = new ArrayList();

        static public int jj_16cm_zyt = 0;



        static public double PID(double head_now)
        {

            CognitiveBiases.HumanFactors.flag_bias_times = 0;
            CognitiveBiases.HumanFactors.is_flag_bias_times();

            CognitiveBiases.HumanFactors.rand_int = 1;
            CognitiveBiases.HumanFactors.flag_bias_times = 0;
            CognitiveBiases.HumanFactors.rand_int = 1;


            double myReturn_Heading = 0;

          

            #endregion

            int shortcut = 0;
            if (
                
                AutoPilot.sendData_toFG_Autopilot.cnt_currentRouteSegment == Route_Information.routeInformation_Storage.my_arrayLists_Route_Segment.Length - 2
                )
            {
            }


            double zyt_jj_1050_man = 0;
            double zyt_jj_1645_man = 0;

            /////
            if (CognitiveBiases.HumanFactors.flag_bias_times == 1
                ||
                (CognitiveBiases.HumanFactors.flag_bias_times == 0
                &&
                CognitiveBiases.HumanFactors.rand_int == 0)
                ||
                shortcut == 1)
            {



                label = 1;
                double u_return = 0;
                //PID参数
                double targetvalue =
                AutoPilot.sendData_toFG_Autopilot.courseAngle(
                    AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target_0,
                    AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target_0,
                    AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                    AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target);
                double currentvalue =
                    AutoPilot.sendData_toFG_Autopilot.courseAngle(
                    AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
                    AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
                    AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                    AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target);

            


                if (targetvalue == 0)
                {
                    double myHeading = AutoPilot.sendData_toFG_Autopilot.courseAngle(
                    AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
                    AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
                    AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                    AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target); ;
                    u_return = myHeading;
                    return u_return;
                }
                double sign = 1;
              
                if (targetvalue == 0)
                {
                    targetvalue += 360;
                }
                double err = targetvalue - currentvalue;

                err = err % 360;

                err_ArrayList.Add(err);
                err_ArrayList_all.Add(err);

                /////////////////////////////////////////////////////
                string err_time = err.ToString() + "," +
                    Convert.ToInt64
                     ((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0)).TotalMilliseconds).
                     ToString();
                errTime_ArrayList.Add(err_time);
                err_ArrayList.Add(err);
                err_ArrayList_all.Add(err);
              
               
                err_sum += err;
                err_sum %= 360;




                kp = Math.Abs(err / targetvalue);//kp;
                ki = Math.Abs(err / err_sum);
                kd = Math.Abs((err - err_last) / err);
               

                //权重初始化：
                double[] array_weight = new double[]
                {
                kp,
                ki,
                kd
                };
                double maxValue = Math.Floor(Max(array_weight)) + 1;
                array_weight[0] /= maxValue;
                array_weight[1] /= maxValue;
                array_weight[2] /= maxValue;
                tc_weights_vector = new double[3, 1];
                //生成3个[0,1]随机变量：
                kp = array_weight[0];
                ki = array_weight[1];
                kd = array_weight[2];

             
                //TC处理：
                TC_Algorithm_weight(kp, ki, kd);
                double kp_0 = kp;
                double ki_0 = ki;
                double kd_0 = kd;
                double kp_1 = tc_weights_vector[0, 0];
                double ki_1 = tc_weights_vector[1, 0];
                double kd_1 = tc_weights_vector[2, 0];

             
                if (kp < ki || kp < kd || kd < ki)
                {
                    double[] array_weight_1 = new double[]
                       {
                     kp,
                     ki,
                     kd };
                    //System.Console.WriteLine(u_return.ToString() + "\t" +
                    //kp.ToString() + "\t" +
                    //ki.ToString() + "\t" +
                    //kd.ToString() + "\t" + "AAAAAAAAAAAAAAAAAAA");

                    double maxValue_1 = Math.Ceiling(Max(array_weight_1)) + 1;//Floor

                    kp = tc_weights_vector[0, 0] / maxValue_1;
                    ki = tc_weights_vector[1, 0] / maxValue_1;
                    kd = tc_weights_vector[2, 0] / maxValue_1;
                }
                //}
                //论文中的位置：效果不咋地，因为sequecnce_kp.Add放错地方了，因为add的是err，不是处理后的权重啊。。。
                //sequecnce_kp.Add(kp);
                //sequecnce_ki.Add(ki);
                //sequecnce_kd.Add(kd);
                Console.WriteLine(
                    "无偏：aaaa" +
                    "err：" + err.ToString() + "aaaa" +
                     "err_sum：" + err_sum.ToString() + "aaaa" +
                     "(err - err_last)：" + (err - err_last).ToString() + "aaaa\n");
                Console.WriteLine(
                    "无偏：aaaa" +
                    "kp：" + kp.ToString() + "aaaa" +
                     "ki：" + ki.ToString() + "aaaa" +
                     "kd：" + kd.ToString() + "aaaa\n");

                double aaaaaaaaaaaaaaaaaaaaaaaaaa = -1645 % 360;
                double w_r = 1;
                double ws = 1;

                if (AutoPilot.sendData_toFG_Autopilot.cnt_currentRouteSegment == Route_Information.routeInformation_Storage.my_arrayLists_Route_Segment.Length - 2
                //&& AutoPilot.decisionMaking.deltaDistance_m <= 26458
                )
                {
                    ki = 0.6;
                    kp = 0.15;
                    kd = 0.15;
                    w_r = 0.8;
                    ws = 1;
                }





                u_return = kp * err + ki * err_sum + kd * (err - err_last);

                u_return %= 360;


                Console.WriteLine(

                    "aaaaaaaaaaaaaaaaaaaaaaaaaa：" + aaaaaaaaaaaaaaaaaaaaaaaaaa.ToString() +
                    "kp * err + ki * err_sum + kd * delta_err" +
                    u_return.ToString() +
                    "aaaa\n");


                if (err_ArrayList.Count == 0)
                    err_last = 0;
              
                double sys_b = 2.0;
                Console.WriteLine(u_return.ToString() + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");

                u_return =
                                     currentvalue

                    +u_return /1
                    ///w_r
                    // / sys_b
                    ;


                
                Console.WriteLine(
                "当前航向：" +
                currentvalue.ToString() +
                "运行一段时间后，真正所需的航向：" +
               AutoPilot.sendData_toFG_Autopilot.courseAngle(
               AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
               AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
               AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
               AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target).ToString() +
                "\t" +
                "目标航向：" +
                targetvalue.ToString() +
                "\t" +
                "决策航向：" +
                u_return.ToString() +
                "\t" + "\n"
                );





                if (u_return.ToString() == "NaN")
                {
                    u_return =
                        
                        AutoPilot.sendData_toFG_Autopilot.courseAngle(
                    AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
                    AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
                    AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                    AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target)
                        
                        ;
                }

                u_return = (u_return + 360) % 360;

                err_last = err;

                //可行，但可能调节的次数太频繁了：
                //kp = tc_weights_vector[0, 0];
                //ki = tc_weights_vector[1, 0];
                //kd = tc_weights_vector[2, 0];
                //未体现偏差对参数影响：
                myReturn_Heading = u_return;

                if (shortcut == 1)
                {
                    int cnt_bias = 0;
                    string[] CognitiveBiases_Names_Time
                    = new string[]
                    {
                    CognitiveBiases.HumanFactors.CognitiveBiases_Names[cnt_bias]
                       
                    };
                    Console.WriteLine(CognitiveBiases.HumanFactors.CognitiveBiases_Names[cnt_bias]);
                    CognitiveBiases.HumanFactors.CognitiveBiases_allName.Add(CognitiveBiases_Names_Time);
                    CognitiveBiases.HumanFactors.bias_times++;
                    CognitiveBiases.HumanFactors.this_time_biasedName = CognitiveBiases.HumanFactors.CognitiveBiases_Names[cnt_bias];
                }
            }
            else
            {

                label = 1;
                double u_return = 0;
                //PID参数
                double targetvalue =
                AutoPilot.sendData_toFG_Autopilot.courseAngle(
                    AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target_0,
                    AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target_0,
                    AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                    AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target);
                double currentvalue =
                    AutoPilot.sendData_toFG_Autopilot.courseAngle(
                    AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
                    AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
                    AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                    AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target);

                if (targetvalue == 0)
                {
                    double myHeading = AutoPilot.sendData_toFG_Autopilot.courseAngle(
                    AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
                    AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
                    AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                    AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target);
                    u_return = myHeading;
                    return u_return;
                }
                double sign = 1;
                if (targetvalue == 0)
                {
                    targetvalue += 360;
                }
                double err = targetvalue - currentvalue;

                err %= 360;

                err_ArrayList.Add(err);
                err_ArrayList_all.Add(err);

                /////////////////////////////////////////////////////
                string err_time = err.ToString() + "," +
                    Convert.ToInt64
                     ((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0)).TotalMilliseconds).
                     ToString();
                errTime_ArrayList.Add(err_time);
                err_ArrayList.Add(err);
                err_ArrayList_all.Add(err);

                //消融实验：
                ArrayList bb = CognitiveBiases_Multiple.HumanFactors.myMain(errTime_ArrayList);

                if (bb.Count == 1)
                {
                    double[] err_doubleVector = (double[])bb[0];
                    double err_new = err_doubleVector[0];
                    double err_sum_new = err_doubleVector[1];
                    double delta_err_new = err_doubleVector[2];
                    double plus_minus_new = err_doubleVector[3];//0代表使用-号，1代表使用+号
                                                                /////////////////////////////////////////////////////


                    //也改了：sign * (targetvalue - currentvalue + 360)%360;
                    //原先targetvalue - currentvalue

                    //old:err = err % 360;
                    //可行位置：（1）
                    //u_return = kp * err + ki * err_sum + kd * (err - err_last);
                    //////////可行位置：（2）
                    //sequecnce_kp.Add(kp);
                    //sequecnce_ki.Add(ki);
                    //sequecnce_kd.Add(kd);
                    err = targetvalue -
                       AutoPilot.sendData_toFG_Autopilot.courseAngle(
                       AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
                       AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
                       AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                       AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target);
                    err_sum += err;

                    err_sum %= 360;


                    ////////////
                    double w_err = err_new;
                    double w_d_err_1 = delta_err_new;
                    double w_err_sum = err_sum_new;
                    if (err_last == 0)
                        kp = Math.Abs(err_new / 1);
                    else
                        kp = Math.Abs(err_new / err_last);//kp;
                                                          //kp = Math.Abs(w_err / targetvalue);//kp;
                    ki = Math.Abs(err / w_err_sum);
                    kd = Math.Abs(w_d_err_1 / err);
                    ////可行位置：（3）：

                    //尝试位置：（4）
                    //u_return = kp * err + ki * err_sum + kd * (err - err_last);


                    //权重初始化：
                    double[] array_weight = new double[]
                    {
                kp,
                ki,
                kd
                    };
                    double maxValue = Math.Floor(Max(array_weight)) + 1;
                    array_weight[0] /= maxValue;
                    array_weight[1] /= maxValue;
                    array_weight[2] /= maxValue;
                    tc_weights_vector = new double[3, 1];
                    //生成3个[0,1]随机变量：
                    kp = array_weight[0];
                    ki = array_weight[1];
                    kd = array_weight[2];
                    //论文中先add误差，再归一化，最后TC处理
                    //sequecnce_kp.Add(kp);
                    //sequecnce_ki.Add(ki);
                    //sequecnce_kd.Add(kd);
                    //TC处理：
                    TC_Algorithm_weight(kp, ki, kd);
                    double kp_0 = kp;
                    double ki_0 = ki;
                    double kd_0 = kd;
                    double kp_1 = tc_weights_vector[0, 0];
                    double ki_1 = tc_weights_vector[1, 0];
                    double kd_1 = tc_weights_vector[2, 0];

                    kp = tc_weights_vector[0, 0];
                    ki = tc_weights_vector[1, 0];
                    kd = tc_weights_vector[2, 0];

                    //归一化：
                    if (kp < ki || kp < kd || kd < ki)
                    {
                        double[] array_weight_1 = new double[]
                    {
                kp,
                ki,
                kd
                    };
                        //System.Console.WriteLine(u_return.ToString() + "\t" +
                        //kp.ToString() + "\t" +
                        //ki.ToString() + "\t" +
                        //kd.ToString() + "\t" + "AAAAAAAAAAAAAAAAAAA");

                        double maxValue_1 = Math.Ceiling(Max(array_weight_1)) + 1;//Floor

                        kp = tc_weights_vector[0, 0] / maxValue_1;
                        ki = tc_weights_vector[1, 0] / maxValue_1;
                        kd = tc_weights_vector[2, 0] / maxValue_1;
                    }




                    sequecnce_kp.Add(kp);
                    sequecnce_ki.Add(ki);
                    sequecnce_kd.Add(kd);
                    sequecnce_kp_all.Add(kp);
                    sequecnce_ki_all.Add(ki);
                    sequecnce_kd_all.Add(kd);



                    //论文中的位置：效果不咋地，因为sequecnce_kp.Add放错地方了，因为add的是err，不是处理后的权重啊。。。
                    //sequecnce_kp.Add(kp);
                    //sequecnce_ki.Add(ki);
                    //sequecnce_kd.Add(kd);
                    //u_return = kp * err + ki * err_sum + kd * (err - err_last);



                    if (err_ArrayList.Count == 0)
                        err_last = 0;
                    err = targetvalue -
                        AutoPilot.sendData_toFG_Autopilot.courseAngle(
                        AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
                        AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
                        AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                        AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target);
                    double delta_err = err - err_last;

                  


                    u_return = kp * err + ki * err_sum + kd * delta_err;

                    
                    double u_return_err = u_return;
                                     

                    double u_return_16 = u_return;

                    
                    u_return = (u_return + 360) % 360;

                    myReturn_Heading = u_return;
                    err_last = targetvalue -
                        AutoPilot.sendData_toFG_Autopilot.courseAngle(
                        AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
                        AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
                        AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                        AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target); ;


                    CognitiveBiases.HumanFactors.is_flag_bias_times();
                    return u_return;
                }


                else
                {
                    double[] bb_vec = new double[bb.Count];

                    for (int i = 0; i < bb.Count; i++)

                    {
                        double[] err_doubleVector = (double[])bb[i];
                        double err_new = err_doubleVector[0];
                        double err_sum_new = err_doubleVector[1];
                        double delta_err_new = err_doubleVector[2];
                        double plus_minus_new = err_doubleVector[3];//0代表使用-号，1代表使用+号
                                                                    /////////////////////////////////////////////////////


                       
                        err = targetvalue -
                           AutoPilot.sendData_toFG_Autopilot.courseAngle(
                           AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
                           AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
                           AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                           AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target);
                        err_sum += err;

                        err_sum %= 360;


                        ////////////
                        double w_err = err_new;
                        double w_d_err_1 = delta_err_new;
                        double w_err_sum = err_sum_new;
                        if (err_last == 0)
                            kp = Math.Abs(err_new / 1);
                        else
                            kp = Math.Abs(err_new / err_last);//kp;
                                                              //kp = Math.Abs(w_err / targetvalue);//kp;
                        ki = Math.Abs(err / w_err_sum);
                        kd = Math.Abs(w_d_err_1 / err);
                      

                     
                       
                        //权重初始化：
                        double[] array_weight = new double[]
                        {
                kp,
                ki,
                kd
                        };
                        double maxValue = Math.Floor(Max(array_weight)) + 1;
                        array_weight[0] /= maxValue;
                        array_weight[1] /= maxValue;
                        array_weight[2] /= maxValue;
                        tc_weights_vector = new double[3, 1];
                        //生成3个[0,1]随机变量：
                        kp = array_weight[0];
                        ki = array_weight[1];
                        kd = array_weight[2];
                        //论文中先add误差，再归一化，最后TC处理
                        //sequecnce_kp.Add(kp);
                        //sequecnce_ki.Add(ki);
                        //sequecnce_kd.Add(kd);
                        //TC处理：
                        TC_Algorithm_weight(kp, ki, kd);
                        double kp_0 = kp;
                        double ki_0 = ki;
                        double kd_0 = kd;
                        double kp_1 = tc_weights_vector[0, 0];
                        double ki_1 = tc_weights_vector[1, 0];
                        double kd_1 = tc_weights_vector[2, 0];

                        kp = tc_weights_vector[0, 0];
                        ki = tc_weights_vector[1, 0];
                        kd = tc_weights_vector[2, 0];

                        //归一化：
                        if (kp < ki || kp < kd || kd < ki)
                        {
                            double[] array_weight_1 = new double[]
                        {
                kp,
                ki,
                kd
                        };
                            //System.Console.WriteLine(u_return.ToString() + "\t" +
                            //kp.ToString() + "\t" +
                            //ki.ToString() + "\t" +
                            //kd.ToString() + "\t" + "AAAAAAAAAAAAAAAAAAA");

                            double maxValue_1 = Math.Ceiling(Max(array_weight_1)) + 1;//Floor

                            kp = tc_weights_vector[0, 0] / maxValue_1;
                            ki = tc_weights_vector[1, 0] / maxValue_1;
                            kd = tc_weights_vector[2, 0] / maxValue_1;
                        }




                        sequecnce_kp.Add(kp);
                        sequecnce_ki.Add(ki);
                        sequecnce_kd.Add(kd);
                        sequecnce_kp_all.Add(kp);
                        sequecnce_ki_all.Add(ki);
                        sequecnce_kd_all.Add(kd);



                        //论文中的位置：效果不咋地，因为sequecnce_kp.Add放错地方了，因为add的是err，不是处理后的权重啊。。。
                        //sequecnce_kp.Add(kp);
                        //sequecnce_ki.Add(ki);
                        //sequecnce_kd.Add(kd);
                        //u_return = kp * err + ki * err_sum + kd * (err - err_last);



                        if (err_ArrayList.Count == 0)
                            err_last = 0;
                        err = targetvalue -
                            AutoPilot.sendData_toFG_Autopilot.courseAngle(
                            AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
                            AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
                            AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                            AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target);
                        double delta_err = err - err_last;

                        double aaaaaaaaaaaaaaaaaaaaaaaaaa = -1645 % 360;//负值，符号取决于-1645




                        Console.WriteLine("aaaaaaaaaaaaaaaaaaaaaaaaaa：" + aaaaaaaaaaaaaaaaaaaaaaaaaa.ToString() +
                            "无偏：aaaa" +
                            "err：" + err.ToString() + "aaaa" +
                             "err_sum：" + err_sum.ToString() + "aaaa" +
                             "(err - err_last)：" + (err - err_last).ToString() + "aaaa\n");
                        Console.WriteLine(
                            "无偏：aaaa" +
                            "kp：" + kp.ToString() + "aaaa" +
                             "ki：" + ki.ToString() + "aaaa" +
                             "kd：" + kd.ToString() + "aaaa\n");




                        if (bias == 'OBias')
                        {
                            weight_process( 'OBias',err_ArrayList );
                            err =((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[0];
                            err_sum = ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[1];
                            delta_err= ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[2];
			 u_return = kp * err + ki * err_sum + kd * delta_err;

                        }
                        else if(bias=='PBias')
                        {
                            weight_process('PBias', err_ArrayList );
                            err =((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[0];
                            err_sum = ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[1];
                            delta_err= ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[2];
 			u_return = kp * err + ki * err_sum + kd * delta_err;
			
                        }
			if(bias=='TBD')
                        {
                            weight_process( 'OBias',err_ArrayList );
                            err =((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[0];
                            err_sum = ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[1];
                            delta_err= ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[2];
			double u_return_1 = kp * err + ki * err_sum + kd * delta_err;        
                
			    weight_process( 'PBias', err_ArrayList );
                            err =((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[0];
                            err_sum = ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[1];
                            delta_err= ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[2];
			double u_return_2 = kp * err + ki * err_sum + kd * delta_err;

                            err =((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[0];
                            err_sum = ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[1];
                            delta_err= ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[2];
			double u_return_3 = kp * err + ki * err_sum + kd * delta_err;


                                 double H_ob=Math.Abs(u_return_1/u_return_3);           
                   		 double H_pb=Math.Abs(u_return_2/u_return_3);
                                 double p_ob=H_pb/(H_ob+H_pb);       
                                 double p_pb=H_nb/(H_ob+H_pb);       

                                int a_ob= Convert.ToInt32(p_ob*100000);     
                                int a_pb= Convert.ToInt32(p_pb*100000);
				ArrayList s_ob_pb =new ArrayList();	


                                for(int i=0;i<a_ob;i++)
				{			s_ob_pb.Add(1);
				}                        
                               for(int i=a_ob;i<a_ob+a_pb;i++)
				{			s_ob_pb.Add(0);
				}
				L=s_ob_pb.Count;       		
				ArrayList s_ob_pb_star =new ArrayList();

                               for(int i=0;i<L;i++)
				{
					int rrr=  AverageRandom(0, L-1-i);
					s_ob_ob_star.Add((int)s_ob_pb[rrr]    );
					s_ob_pb.RemoveAt(rrr);
				}
                               int rrr_star=  AverageRandom(0, L);
                               int bias_label=(int)s_ob_ob_star[rrr_star];
                               if(bias_label==0)
				{	 weight_process('PBias', err_ArrayList );
                          	  err =((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[0];
                           	 err_sum = ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[1];
                           	 delta_err= ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[2];
 				u_return = kp * err + ki * err_sum + kd * delta_err;
				}
				if(bias_label==1)
				{	
					weight_process( 'OBias',err_ArrayList );
                            err =((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[0];
                            err_sum = ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[1];
                            delta_err= ((string[]) err_ArrayList_new [err_ArrayList_new .Count-1]_[2];
			 u_return = kp * err + ki * err_sum + kd * delta_err;
				}
                        }





                       


                        double u_return_err = u_return;




			u_return = currentvalue + u_return ;

                       
                        u_return = (u_return + 360) % 360;

                        myReturn_Heading = u_return;
                        err_last = targetvalue -
                            AutoPilot.sendData_toFG_Autopilot.courseAngle(
                            AutoPilot.decisionMaking.trueValue("position-longitude-deg"),
                            AutoPilot.decisionMaking.trueValue("position-latitude-deg"),
                            AutoPilot.sendData_toFG_Autopilot.myLongitude_RouteSegment_Target,
                            AutoPilot.sendData_toFG_Autopilot.myLatitude_RouteSegment_Target); ;

                           u_return = Math.Floor(u_return);
                        
                    }

                   




                return u_return;
            }
            return myReturn_Heading;
        }
        static public void pid_Initialization()
        {
            err_sum = 0;
            err_last = 0;
        }

        //计算相关性：
        static public ArrayList sequecnce_kp = new ArrayList();
        static public ArrayList sequecnce_ki = new ArrayList();
        static public ArrayList sequecnce_kd = new ArrayList();
        static public ArrayList sequecnce_kp_all = new ArrayList();
        static public ArrayList sequecnce_ki_all = new ArrayList();
        static public ArrayList sequecnce_kd_all = new ArrayList();


        static public double rou_calculate(ArrayList sequecnce_0, ArrayList sequecnce_1)
        {
            double rou_sequecnce_0_sequecnce_1 = 0;
            double sum_0 = 0;
            double sum_1 = 0;
            //一段航线一更新ArrayList
            for (int i = 0; i < sequecnce_0.Count; i++)
            {
                double data_0 = (double)sequecnce_0[i];
                sum_0 += data_0;
                double data_1 = (double)sequecnce_1[i];
                sum_1 += data_1;
            }
            double average_0 = sum_0 * 1.0 / sequecnce_0.Count;
            double average_1 = sum_1 * 1.0 / sequecnce_1.Count;

            double cov_0_1 = 0;
            for (int i = 0; i < sequecnce_0.Count; i++)
            {
                double data_0 = (double)sequecnce_0[i];
                double data_1 = (double)sequecnce_1[i];
                cov_0_1 += (data_0 - average_0) * (data_1 - average_1);
            }
            double sigma_0 = 0;
            for (int i = 0; i < sequecnce_0.Count; i++)
            {
                double data_0 = (double)sequecnce_0[i];
                sigma_0 += (data_0 - average_0) * (data_0 - average_0);
            }
            sigma_0 = Math.Pow(sigma_0, 0.5);

            double sigma_1 = 0;
            for (int i = 0; i < sequecnce_1.Count; i++)
            {
                
                double data_1 = (double)sequecnce_1[i];
                sigma_1 += (data_1 - average_1) * (data_1 - average_1);
            }
            sigma_1 = Math.Pow(sigma_1, 0.5);
            if (sigma_0 == 0 || sigma_1 == 0)
                rou_sequecnce_0_sequecnce_1 = random_min_max(0, 1);
            else
                rou_sequecnce_0_sequecnce_1 = cov_0_1 * 1.0 / sigma_0 / sigma_1;

            return rou_sequecnce_0_sequecnce_1;
        }






        //TC：
        static public double rou_1_2 = 0;
        static public double rou_1_3 = 0;
        static public double rou_2_3 = 0;
        //相关性矩阵
        static public double[,] sigma;

        //生成随机数
        static public double random_min_max(int min, int max)
        {
            Random aa = new Random((int)(DateTime.Now.Ticks / 10000));


            int MINnteger = (int)(min * 10000);//包括0
            int MAXnteger = (int)(max * 10000 + 1);//由于不包括max+1
            int resultInteger = aa.Next(MINnteger, MAXnteger);
            double return_resultInteger = resultInteger / 10000.0;
            return return_resultInteger;
        }
        //初始化rou值，指定三个变量的关联性，生成sigma矩阵





        public static void rou_i_j_Generation()
        {
            //rou计算：
            //double rou_1_2 = -0.5;
            //double rou_1_3 = 0.5;
            //double rou_2_3 = -0.3;

            //rou_1_2 = -0.5;
            //rou_1_3 = 0.5;
            //rou_2_3 = -0.3;

            rou_1_2 = -1 * rou_calculate(sequecnce_kp, sequecnce_ki);
            rou_1_3 = rou_calculate(sequecnce_kp, sequecnce_kd);
            rou_2_3 = -1 * rou_calculate(sequecnce_ki, sequecnce_kd);

            double rou_sum_2 = rou_1_2 * rou_1_2 + rou_1_3 * rou_1_3 + rou_2_3 * rou_2_3;
            if (rou_sum_2 >= 1)
            {
                rou_sum_2 = Math.Floor(rou_sum_2) + 1;
                rou_sum_2 = Math.Pow(rou_sum_2, 0.5);
                rou_1_2 = rou_1_2 * 1.0 / rou_sum_2;
                rou_1_3 = rou_1_3 * 1.0 / rou_sum_2;
                rou_2_3 = rou_2_3 * 1.0 / rou_sum_2;
            }


                    }

        //具有相关性rou_i_j()的、三元相关性的3*1列向量：
        static public double[,] tc_weights_vector;

        //三元相关性计算，得到数值：
        public static void TC_Algorithm()
        {
            //权重初始化：
            tc_weights_vector = new double[3, 1];
            //生成3个[0,1]随机变量：
            double v_1 = random_min_max(0, 1);
            double v_2 = random_min_max(0, 1);
            double v_3 = random_min_max(0, 1);
            //三元相关因子计算：
            NSMatrix.Matrix tc_weight = C(v_1, v_2, v_3);
            //数值：
            tc_weights_vector[0, 0] = tc_weight[0, 0];
            tc_weights_vector[1, 0] = tc_weight[1, 0];
            tc_weights_vector[2, 0] = tc_weight[2, 0];
        }

        //三元权重：
        public static void TC_Algorithm_weight(double w_1, double w_2, double w_3)
        {
            //三元相关因子计算：
            NSMatrix.Matrix tc_weight = C(w_1, w_2, w_3);
            //数值：
            tc_weights_vector[0, 0] = tc_weight[0, 0];
            tc_weights_vector[1, 0] = tc_weight[1, 0];
            tc_weights_vector[2, 0] = tc_weight[2, 0];
        }

        //最大值：
        static public double Max_old(double[] array)
        {
            if (array.Length == 1) return array[0];
            for (int j = 0; j < array.Length - 1; j++)
            {
                if (array[j] > array[j + 1])
                {
                    double temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
            return array[array.Length - 1];
        }
        static public double Min(double[] array)
        {
            double[] a_copy = new double[array.Length];
            Array.Copy(array, a_copy, array.Length);
            if (a_copy.Length == 1) return a_copy[0];
            for (int j = 0; j < a_copy.Length - 1; j++)
            {
                if (a_copy[j] < a_copy[j + 1])
                {
                    double temp = a_copy[j];
                    a_copy[j] = a_copy[j + 1];
                    a_copy[j + 1] = temp;
                }
            }
            return a_copy[a_copy.Length - 1];
        }


        static public double Max(double[] array)
        {
            double[] a_copy = new double[array.Length];
            Array.Copy(array, a_copy, array.Length);
            if (a_copy.Length == 1) return a_copy[0];
            for (int j = 0; j < a_copy.Length - 1; j++)
            {
                if (a_copy[j] > a_copy[j + 1])
                {
                    double temp = a_copy[j];
                    a_copy[j] = a_copy[j + 1];
                    a_copy[j + 1] = temp;
                }
            }
            return a_copy[a_copy.Length - 1];
        }

        static public NSMatrix.Matrix Cholsym(NSMatrix.Matrix A) //Choleskey分解
        {
            int n = A.Columns;//列
            int m = A.Rows;   //行
            NSMatrix.Matrix D = new NSMatrix.Matrix(m, n);
            D[0, 0] = Math.Sqrt(A[0, 0]);
            for (int j = 1; j < n; j++)
            {
                D[j, 0] = A[0, j] / D[0, 0];
            }
            double s_i_k_j_k = 0, s_i_k_i_k = 0;
            for (int i = 1; i < m; i++)
            {
                for (int k = 0; k < i; k++)
                {
                    s_i_k_i_k += D[i, k] * D[i, k];
                }
                D[i, i] = Math.Sqrt(A[i, i] - s_i_k_i_k);
                double a = D[i, i];

                for (int j = i; j < n; j++)
                {
                    for (int k = 0; k < j; k++)
                    {
                        s_i_k_j_k += D[i, k] * D[j, k];
                    }
                    D[j, i] = (A[i, j] - s_i_k_j_k) / D[i, i];
                    s_i_k_j_k = 0;
                    s_i_k_i_k = 0;
                }
            }
            for (int i = 0; i < D.Rows; i++)
            {
                for (int j = 0; j < D.Columns; j++)
                {
                    double a = D[i, j];
                    string aa = D[i, j].ToString();
                    if (D[i, j].ToString() == "NaN")
                        D[i, j] = 1;
                }
            }

            return D;
        }

        static public NSMatrix.Matrix C(double R1, double R2, double U)
        {
            //相关性参数初始化：
            rou_i_j_Generation();
            //三元相关性值计算：
            double k1 = rou_1_2;
            double k2 = rou_1_3;
            double k3 = rou_2_3;
            double[,] A_data =
            {
                { 1, k1, k2 },
                { k1, 1, k3 },
                { k2, k3, 1 }
            };
            NSMatrix.Matrix A = new NSMatrix.Matrix(A_data);
            NSMatrix.Matrix D = Cholsym(A);
            D = D.Transpose();
            //逆：
            double[,] Z_data = { { Norminv(R1) }, { Norminv(R2) }, { Norminv(U) } };
            NSMatrix.Matrix Z = new NSMatrix.Matrix(Z_data);
            NSMatrix.Matrix Y = D * Z;
            //CDF：
            double v0 = NORMSDIST(Y[0, 0]);
            double v1 = NORMSDIST(Y[1, 0]);
            double v2 = NORMSDIST(Y[2, 0]);
            Z_data[0, 0] = v0;
            Z_data[1, 0] = v1;
            Z_data[2, 0] = v2;
            NSMatrix.Matrix Z_Return = new NSMatrix.Matrix(Z_data);
            return Z_Return;
        }

        #region
        //乔莱斯基分解
        public static double[,] Choleskey_Decomposition(double[,] matrix)
        {
            int n = matrix.GetLength(0);
            double[,] lower = new double[n, n];

            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j <= i; j++)
                {
                    double sum = 0;
                    if (j == i)
                    {
                        for (int k = 0; k < j; k++)
                        {
                            sum += (double)Math.Pow(lower[j, k], 2);
                        }
                        lower[j, j] = (double)Math.Sqrt(matrix[j, j] - sum);
                    }
                    else
                    {
                        for (int k = 0; k < j; k++)
                        {
                            sum += (lower[i, k] * lower[j, k]);
                        }
                        lower[i, j] = (matrix[i, j] - sum) / lower[j, j];
                    }
                }
            }

            return lower;
        }
        //高斯：均值u，方差d，变量a
        static public double GetGaussDistributeRandom(double u, double d, double a)
        {
            double u1, u2, z, x;
            u1 = a;
            u2 = u1;
            z = Math.Sqrt(-2 * Math.Log(u1)) * Math.Sin(2 * Math.PI * u2);
            x = u + d * z;
            return x;
        }
        //产生随机种子 
        public static int GetRandomSeed()
        {
            byte[] bytes = new byte[4];
            System.Security.Cryptography.RNGCryptoServiceProvider rng
                = new System.Security.Cryptography.RNGCryptoServiceProvider();
            rng.GetBytes(bytes);
            return BitConverter.ToInt32(bytes, 0);
        }
        //正态累积函数
        static public double MyNormcdf(double x)
        {
            // constants
            double a1 = 0.254829592;
            double a2 = -0.284496736;
            double a3 = 1.421413741;
            double a4 = -1.453152027;
            double a5 = 1.061405429;
            double p = 0.3275911;

            // Save the sign of x
            int sign = 1;
            if (x < 0)
                sign = -1;
            x = Math.Abs(x) / Math.Sqrt(2.0);

            // A&S formula 7.1.26
            double t = 1.0 / (1.0 + p * x);
            double y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.Exp(-x * x);
            return 0.5 * (1.0 + sign * y);
        }
        #endregion

        //指定平均值和标准偏差，返回正态累积分布函数的反函数值
        static public double Norminv(double p)
        {
            double LOW = 0.02425;
            double HIGH = 0.97575;
            double[] a =
                {
                -3.969683028665376e+01,
                2.209460984245205e+02,
                -2.759285104469687e+02,
                1.383577518672690e+02,
                -3.066479806614716e+01,
                2.506628277459239e+00
            };
            double[] b =
                {
                -5.447609879822406e+01,
                1.615858368580409e+02,
                -1.556989798598866e+02,
                6.680131188771972e+01,
                -1.328068155288572e+01
            };
            double[] c =
                {
                -7.784894002430293e-03,
                -3.223964580411365e-01,
                -2.400758277161838e+00,
                -2.549732539343734e+00,
                4.374664141464968e+00,
                2.938163982698783e+00
            };
            double[] d =
                {
                7.784695709041462e-03,
                3.224671290700398e-01,
                2.445134137142996e+00,
                3.754408661907416e+00
            };

            double q, r;
            if (p < 0 || p > 1)
            {

                return 0.0;
            }
            else if (p == 0)
            {
                return -Infinity; /* minus "infinity" */;
            }
            else if (p == 1)
            {
                return Infinity; /* "infinity" */;
            }
            else if (p < LOW)
            {
                q = Math.Sqrt(-2 * Math.Log(p));
                return (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
                    ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            }
            else if (p > HIGH)
            {
                /* Rational approximation for upper region */
                q = Math.Sqrt(-2 * Math.Log(1 - p));
                return -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
                    ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            }
            else
            {
                /* Rational approximation for central region */
                q = p - 0.5;
                r = q * q;
                return (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q /
                    (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);
            }
        }

        //无穷：
        public static double Infinity { get; private set; }

        //均值0，方差1，累积分布：
        public static double NORMSDIST(double a)
        {
            double p = 0.2316419;
            double b1 = 0.31938153;
            double b2 = -0.356563782;
            double b3 = 1.781477937;
            double b4 = -1.821255978;
            double b5 = 1.330274429;
            double x = Math.Abs(a);
            double t = 1 / (1 + p * x);
            double val = 1 -
                (1
                / (Math.Sqrt(2 * Math.PI))
                * (Math.Pow(Math.E, -1 * Math.Pow(a, 2) / 2)))
                * (b1 * t + b2 * Math.Pow(t, 2)
                + b3 * Math.Pow(t, 3) + b4
                * Math.Pow(t, 4) + b5
                * Math.Pow(t, 5));

            if (a < 0)
            {
                val = 1 - val;
            }

            return val;
        }
    }

static public double phi_0(int i, int n)
{
	    double  x= System.Convert.ToDouble(3.0*i/n);
            double constant = 1.0 / Math.Sqrt(2 * Math.PI);
            double exponent = -x * x / 2.0;
            double pdfValue = constant * Math.Exp(exponent);
            return pdfValue;
}

static public double phi_1(int i, int n)
{
	    double  x= System.Convert.ToDouble(3.0*i/n);
	    double cdfValue = (1.0 + Erf(x / Math.Sqrt(2.0))) / 2.0;
            return cdfValue;
}
        // 误差函数
        // C#没有内置的误差函数，这里使用近似的方法计算
        private static double Erf(double x)
        {
            // 确保x的值在合理范围内
            if (x <= -10.0)
                return -1.0;
            if (x >= 10.0)
                return 1.0;

            double result = 0.0;
            double term = x;
            int n = 1;
            while (result + term != result)
            {
                result += term;
                term *= x * x / n;
                n += 2;
            }

            return result * 2.0 / Math.Sqrt(Math.PI);
        }

       
static public void weight_process(string bias, ArrayList Arr)
{
if(bias=='OBias')
{
      if(Arr.Count==1)
      {
		double err_last=((double)Arr[Arr.Count-1]);
	        double w=2*phi_0(0,Arr.Count)*phi_1(0,Arr.Count);
                err_last= err_last*w;
		 double err_sum= err_last;
               double err_delta=0;
               double[]r=new double[]{err_last, err_sum, err_delta};
		     err_ArrayList_new.Add(r);
      }

      if(Arr.Count<7 && Arr.Count>1)
	{
		double err_last=((double)Arr[Arr.Count-1]);
                double err_sum=0;
		for(int i=0;i<Arr.Count;i++)
		{       double err_i=((double)Arr[i]);
			double w=2*phi_0(i,Arr.Count-1)*phi_1(i,Arr.Count-1);
			 err_sum=err_i*w;
		}
               double err_delta=0;
	       double err_last_minus_1=((double)Arr[Arr.Count-2]);		
        	double w_last=2*phi_0(0,Arr.Count-1)*phi_1(0,Arr.Count-1);       
         	double w_last_minus_1=2*phi_0(1,Arr.Count-1)*phi_1(1,Arr.Count-1);
		err_delta=err_delta*w_last-err_last_minus_1*w_last_minus_1;         
              double[]r=new double[]{err_last, err_sum, err_delta};
              		     err_ArrayList_new.Add(r);
	}
	else
	{
		double err last=((double)Arr[Arr.Count-1]);
                double err_sum=0;
		for(int i=Arr.Count-7;i<Arr.Count;i++)
		{       double err_i=((double)Arr[i]);
			double w=2*phi_0(6-(Arr.Count-1-i),Arr.Count-1)*phi_1(6-(Arr.Count-1-i),Arr.Count-1);
			 err_sum=err_i*w;
		}
               double err_delta=0;
	       double err_last_minus_1=((double)Arr[Arr.Count-2]);		
        	double w_last=2*phi_0(0,7-1)*phi_1(0,7-1);       
         	double w_last_minus_1=2*phi_0(1,7-1)*phi_1(1,7-1);
		err_delta=err_delta*w_last-err_last_minus_1*w_last_minus_1;         
              double[]r=new double[]{err_last, err_sum, err_delta};
              		     err_ArrayList_new.Add(r);
	}
}

if(bias=='PBias')
{
      if(Arr.Count==1)
      {
		double err_last=((double)Arr[Arr.Count-1]);
	        double w=2*phi_0(-1*0,Arr.Count)*phi_1(-1*0,Arr.Count);
                err_last= err_last*w;
		 double err_sum= err_last;
               double err_delta=0;
               double[]r=new double[]{err_last, err_sum, err_delta};
		     err_ArrayList_new.Add(r);
      }

      if(Arr.Count<7 && Arr.Count>1)
	{
		double err_last=((double)Arr[Arr.Count-1]);
                double err_sum=0;
		for(int i=0;i<Arr.Count;i++)
		{       double err_i=((double)Arr[i]);
			double w=2*phi_0(-1*i,Arr.Count-1)*phi_1(-1*i,Arr.Count-1);
			 err_sum=err_i*w;
		}
               double err_delta=0;
	       double err_last_minus_1=((double)Arr[Arr.Count-2]);		
        	double w_last=2*phi_0(-1*0,Arr.Count-1)*phi_1(-1*0,Arr.Count-1);       
         	double w_last_minus_1=2*phi_0(-1*1,Arr.Count-1)*phi_1(-1*1,Arr.Count-1);
		err_delta=err_delta*w_last-err_last_minus_1*w_last_minus_1;         
              double[]r=new double[]{err_last, err_sum, err_delta};         
		     err_ArrayList_new.Add(r);
              
	}
	else
	{
		double err last=((double)Arr[Arr.Count-1]);
                double err_sum=0;
		for(int i=Arr.Count-7;i<Arr.Count;i++)
		{       double err_i=((double)Arr[i]);
			double w=2*phi_0(-1*(6-(Arr.Count-1-i)),Arr.Count-1)*phi_1(-1*(6-(Arr.Count-1-i)),Arr.Count-1);
			 err_sum=err_i*w;
		}
               double err_delta=0;
	       double err_last_minus_1=((double)Arr[Arr.Count-2]);		
        	double w_last=2*phi_0(-1*0,7-1)*phi_1(-1*0,7-1);       
         	double w_last_minus_1=2*phi_0(-1*1,7-1)*phi_1(-1*1,7-1);
		err_delta=err_delta*w_last-err_last_minus_1*w_last_minus_1;         
              double[]r=new double[]{err_last, err_sum, err_delta};
              err_ArrayList_new.Add(r);
	}
}


}




}


public static int AverageRandom(double min, double max)//产生(min,max)之间均匀分布的随机数
        {
            int myWeight_Double_return;
            Random aa = new Random();
            int MINnteger = (int)(min * 10000);
            int MAXnteger = (int)(max * 10000);
            int resultInteger = aa.Next(MINnteger, Mantiger + 1);//随机数包括MINnteger，不包括MAXnteger            
            if (resultInteger == MAXnteger)
                resultInteger -= 1;
            double myWeight_Double = resultInteger / 10000.0;
            myWeight_Double_return = (int)myWeight_Double;
            return myWeight_Double_return;
        }





static public void workingMemory_DM_p5()//_head 
        {
            if (AutoPilot.workingMemory_Subsystem.workingMemoryStorage_data_all.Count == 0)
                return;
            mark_dis = assessment_dis();
            mark_ABC = assessment_ABC();
            if (workingMemory_DM_cnt == 0)
            {
                mark_ABC_last = mark_ABC;
                mark_dis_last = mark_dis;
            }
            workingMemory_DM_flag_bias_or_not = 0;//无偏
            ArrayList aaa_aa = new ArrayList();//深拷贝
            aaa_aa = AutoPilot.workingMemory_Subsystem.workingMemoryStorage_data_all;
            if (aaa_aa.Count == 0)
            {
                return;
            }
            ArrayList cca = new ArrayList();
            if (aaa_aa.Count < AutoPilot.workingMemory_Subsystem.myThreshold_Length_workingMemoryStorage)
            {
                workingMemory_DM_flag_bias_or_not = 0;//无偏
                cca.Add(workingMemory_DM_flag_bias_or_not);
                cca.Add(aaa_aa);
                aaa_aa_all.Add(cca);
                cca = new ArrayList();
                return;
                //return workingMemory_DM_flag_bias_or_not;
            }
            else
            {
                ArrayList aaa_aa_0 = new ArrayList();
                aaa_aa_0 = aaa_aa;
                aaa_aa = new ArrayList();
                for (int i = 0; i < AutoPilot.workingMemory_Subsystem.myThreshold_Length_workingMemoryStorage; i++)
                {
                     if (aaa_aa_0[aaa_aa_0.Count - AutoPilot.workingMemory_Subsystem.myThreshold_Length_workingMemoryStorage + i] != null)

                        aaa_aa.Add((string[])aaa_aa_0[aaa_aa_0.Count - AutoPilot.workingMemory_Subsystem.myThreshold_Length_workingMemoryStorage + i]);
                }
            }
            ArrayList stringVec_workingMemory = new ArrayList();//全部
            ArrayList stringVec_workingMemory_name = new ArrayList();//名字
            ArrayList stringVec_workingMemory_value = new ArrayList();//数值
            for (int i = 0; i < AutoPilot.workingMemory_Subsystem.myThreshold_Length_workingMemoryStorage; i++)
            {
                if (i >= aaa_aa.Count)
                    break;
                if (aaa_aa[aaa_aa.Count - 1 - i] == null)
                    continue;
                stringVec_workingMemory.Add((string[])
                    aaa_aa[aaa_aa.Count - 1 - i]);
                stringVec_workingMemory_name.
                    Add(((string[])
                    aaa_aa[aaa_aa.Count - 1 - i])[0]);
                stringVec_workingMemory_value.
                   Add(((string[])
                   aaa_aa[aaa_aa.Count - 1 - i])[0]);
            }
            int flag_arrayLayoutDesign_AircraftCockpit_Level_1_new_Dis_Need = 0;
            ArrayList ArrayList_flag_arrayLayoutDesign_AircraftCockpit_Level_1_new_Dis_Need = new ArrayList();
            for (int i = 1; i < arrayLayoutDesign_AircraftCockpit_Level_1_new_Dis_Need.Count; i++)
            {
                string name_arrayLayoutDesign_AircraftCockpit_Level_1_new_Dis_Need = (string)(arrayLayoutDesign_AircraftCockpit_Level_1_new_Dis_Need[i]);
                for (int j = 0; j < Map_Chinese_English.Length; j++)
                {
                    string j_name = Map_Chinese_English[j];
                    string[] vec = j_name.Split(";");
                    if (vec[0] == name_arrayLayoutDesign_AircraftCockpit_Level_1_new_Dis_Need)
                    {
                        name_arrayLayoutDesign_AircraftCockpit_Level_1_new_Dis_Need = vec[1];
                        break;
                    }
                }
                for (int j = 0; j < stringVec_workingMemory_name.Count; j++)
                {
                    string j_name = (string)stringVec_workingMemory_name[j];
                    if (name_arrayLayoutDesign_AircraftCockpit_Level_1_new_Dis_Need == j_name)
                        ArrayList_flag_arrayLayoutDesign_AircraftCockpit_Level_1_new_Dis_Need.Add(j_name);
                }
            }
            flag_arrayLayoutDesign_AircraftCockpit_Level_1_new_Dis_Need = ArrayList_flag_arrayLayoutDesign_AircraftCockpit_Level_1_new_Dis_Need.Count;
            int flag_arrayLayoutDesign_AircraftCockpit_Level_2_new_LoR_Need = 0;
            ArrayList ArrayList_flag_arrayLayoutDesign_AircraftCockpit_Level_2_new_LoR_Need = new ArrayList();
            for (int i = 1; i < arrayLayoutDesign_AircraftCockpit_Level_2_new_LoR_Need.Count; i++)
            {
                string name_arrayLayoutDesign_AircraftCockpit_Level_2_new_LoR_Need = (string)(arrayLayoutDesign_AircraftCockpit_Level_2_new_LoR_Need[i]);
                for (int j = 0; j < Map_Chinese_English.Length; j++)
                {
                    string j_name = Map_Chinese_English[j];
                    string[] vec = j_name.Split(";");
                    if (vec[0] == name_arrayLayoutDesign_AircraftCockpit_Level_2_new_LoR_Need)
                    {
                        name_arrayLayoutDesign_AircraftCockpit_Level_2_new_LoR_Need = vec[1];
                        break;
                    }
                }
                for (int j = 0; j < stringVec_workingMemory_name.Count; j++)
                {
                    string j_name = (string)stringVec_workingMemory_name[j];
                    if (name_arrayLayoutDesign_AircraftCockpit_Level_2_new_LoR_Need == j_name)
                        ArrayList_flag_arrayLayoutDesign_AircraftCockpit_Level_2_new_LoR_Need.Add(j_name);
                }
            }
            flag_arrayLayoutDesign_AircraftCockpit_Level_2_new_LoR_Need = ArrayList_flag_arrayLayoutDesign_AircraftCockpit_Level_2_new_LoR_Need.Count;

            int label_bias = 0;
            ArrayList ArrayList_label_bias = new ArrayList();





            if (
                AutoPilot.receiveData_fromFG_toRecord_for_HeadingAdjustment.send_mark.Count != 0
                )
            {

                //string mark_0 = (string)AutoPilot.receiveData_fromFG_toRecord_for_HeadingAdjustment.send_mark
                //    [AutoPilot.receiveData_fromFG_toRecord_for_HeadingAdjustment.send_mark.Count - 1];
                //string[] mark_0_vec = mark_0.Split(",");

                //mark_dis_last = Convert.ToDouble(mark_0_vec[0]);
                //mark_ABC_last = Convert.ToDouble(mark_0_vec[1]);

                if (mark_ABC_last_ArrayList.Count != 0 && mark_dis_last_ArrayList.Count != 0)
                {

                    mark_dis_last = Convert.ToDouble((double)mark_dis_last_ArrayList[mark_dis_last_ArrayList.Count - 1]);
                    mark_ABC_last = Convert.ToDouble((double)mark_ABC_last_ArrayList[mark_ABC_last_ArrayList.Count - 1]);

                }
                else
                {
                    string mark_0 = (string)AutoPilot.receiveData_fromFG_toRecord_for_HeadingAdjustment.send_mark
                        [AutoPilot.receiveData_fromFG_toRecord_for_HeadingAdjustment.send_mark.Count - 1];
                    if (mark_0 == null)
                    {
                        for (int kptr = AutoPilot.receiveData_fromFG_toRecord_for_HeadingAdjustment.send_mark.Count - 2; kptr >= 0; kptr--)
                        {
                            mark_0 = (string)AutoPilot.receiveData_fromFG_toRecord_for_HeadingAdjustment.send_mark[kptr];
                            if (mark_0 != null)
                                break;
                        }
                    }

                    string[] mark_0_vec = mark_0.Split(",");

                    mark_dis_last = Convert.ToDouble(mark_0_vec[0]);
                    mark_ABC_last = Convert.ToDouble(mark_0_vec[1]);
                }

                //mark_ABC_last_ArrayList
            }
            if (workingMemory_DM_cnt == 0)
            {
                mark_ABC_last = mark_ABC;
                mark_dis_last = mark_dis;
            }
            else
            if (
                AutoPilot.decisionMaking.heaiding_flag == 1)
            {


                if (mark_ABC_last_ArrayList.Count != 0 && mark_dis_last_ArrayList.Count != 0)
                {

                    mark_dis_last = Convert.ToDouble((double)mark_dis_last_ArrayList[mark_dis_last_ArrayList.Count - 1]);
                    mark_ABC_last = Convert.ToDouble((double)mark_ABC_last_ArrayList[mark_ABC_last_ArrayList.Count - 1]);

                }
                else
                {
                    mark_ABC_last = mark_ABC;
                    mark_dis_last = mark_dis;
                }
                AutoPilot.decisionMaking.heaiding_flag = 0;
            }

            else
            {

                if (mark_ABC_last_ArrayList.Count != 0 && mark_dis_last_ArrayList.Count != 0)
                {

                    mark_dis_last = Convert.ToDouble((double)mark_dis_last_ArrayList[mark_dis_last_ArrayList.Count - 1]);
                    mark_ABC_last = Convert.ToDouble((double)mark_ABC_last_ArrayList[mark_ABC_last_ArrayList.Count - 1]);

                }
                else
                {
                    mark_ABC_last = mark_ABC;
                    mark_dis_last = mark_dis;
                }
            }

            int flag_now_bias = 0;
            workingMemory_DM_cnt = 1;


            ////阈值：  2500 
            

            //阈值：  2500 

            ////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////

            double theta_value_same =2;
            double theta_recencyEffect = theta_value_same;//1//2//155，之差大于等于
            double theta_slightlyOptimism = theta_value_same;//1//2//155，小于；-1，才会不触发SO
            ////////////////////////////////////////////////////////////
            double theta_lossAversion = 3000;//1//2//155
            double theta_zeroRisk = 1;//1//2//155
            AutoPilot.receiveData_fromFG_toRecord_for_HeadingAdjustment.theta_primacyEffect = 11;//为了文件保存
            ////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////

            

            double th_here_1 = AutoPilot.receiveData_fromFG_toRecord_for_HeadingAdjustment.theta_primacyEffect % 10;
            double th_here_2 = Math.Floor(AutoPilot.receiveData_fromFG_toRecord_for_HeadingAdjustment.theta_primacyEffect / 10.0);


           
            double sign_vect_double_9_10 = 1;

            double vect_double = 0;

        sign_vect_double_9_10 = th_here_2 / th_here_1 * mark_dis;

            if (sign_vect_double_9_10==0)
            {
                label_bias = 9;
                //label_bias = 4;
                ArrayList_label_bias.Add(label_bias);
                label_bias = 10;
                ArrayList_label_bias.Add(label_bias);
                flag_now_bias = 1;
                //Algorithm.TC_pid.jj_16cm_zyt = 0;
            }

            else {
                double vect_double_9 = 1.0 * (mark_dis * th_here_1 + mark_ABC * th_here_2)
                       /
                       Math.Sqrt(mark_dis * mark_dis + mark_ABC * mark_ABC) /
                       Math.Sqrt(th_here_1 * th_here_1 + th_here_2 * th_here_2)

                       ;

                if (vect_double_9 > mark_ABC)
                    sign_vect_double_9_10 = -1;
                if (vect_double_9 < mark_ABC)
                    sign_vect_double_9_10 = 1;
                 vect_double =
                   (1 - Math.Pow(Math.E, vect_double_9)) /
                   (1 + Math.Pow(Math.E, vect_double_9)) *
                   1.0
                   * sign_vect_double_9_10;

                if ((vect_double < 0) && (((mark_dis - mark_dis_last) <= 0)||(mark_head - mark_head_last) <= 0)))
            {
                label_bias = 9;
             bias=='PBias'
                //label_bias = 4;
                ArrayList_label_bias.Add(label_bias);
                flag_now_bias = 1;
                    Algorithm.TC_pid.jj_16cm_zyt = 9;
                }

           else if (vect_double > 0&&  (((mark_dis - mark_dis_last) > 0)||(mark_head - mark_head_last) > 0)))
            {
                label_bias = 10;
            bias=='OBias'

                //label_bias = 4;
                ArrayList_label_bias.Add(label_bias);
                flag_now_bias = 1;
                Algorithm.TC_pid.jj_16cm_zyt = 10;
                }
            }
          else

		bias=='TBD';
          



            //0b:
            if (flag_now_bias == 0)
            {
                label_bias = 0;
                ArrayList_label_bias.Add(label_bias);
                Algorithm.TC_pid.jj_16cm_zyt = 0;
            }


            ////更新：
            //mark_ABC_last = mark_ABC;
            //mark_dis_last = mark_dis;


          

            if (ArrayList_label_bias.Count != 0)
            {
                if (ArrayList_label_bias.Count == 1)
                {
                    workingMemory_DM_flag_bias_or_not = (int)ArrayList_label_bias[0];

                    cca.Add(workingMemory_DM_flag_bias_or_not.ToString());
                    cca.Add(aaa_aa);
                    aaa_aa_all.Add(cca);
                    cca = new ArrayList();
                    return;
                    //return workingMemory_DM_flag_bias_or_not;
                }
                else
                {
                    string[,] aabb = new string[ArrayList_label_bias.Count, 2];
                    string str_aaaaabbbbbb = "";
                    for (int i = 0; i < ArrayList_label_bias.Count; i++)
                    {
                        //格式：数值+比例
                        aabb[i, 0] = ((int)(ArrayList_label_bias[i])).ToString();
                        str_aaaaabbbbbb += aabb[i, 0] + ",";
                    }





                    cca.Add(str_aaaaabbbbbb);
                    cca.Add(aaa_aa);
                    aaa_aa_all.Add(cca);
                    cca = new ArrayList();
                    return;//return workingMemory_DM_flag_bias_or_not;
                }


            }
            else
            {
                workingMemory_DM_flag_bias_or_not = 0;

                cca.Add(workingMemory_DM_flag_bias_or_not.ToString());
                cca.Add(aaa_aa);
                aaa_aa_all.Add(cca);
                cca = new ArrayList();
            }
            Console.WriteLine("ccccccccccccccccccccccccccc" + "\t" + "\t"
                + workingMemory_DM_flag_bias_or_not.ToString() + "\t" + "\t" +
                "ccccccccccccccccccccccccccc");



            return;
            
        }
